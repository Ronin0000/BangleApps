<html>
  <head>
    <style>
      body { padding:0; margin:0; }
      html, body, #map { height:100%; width:100%; }
      #controls {
        padding:10px; margin:10px; border:1px solid black;
        position:absolute; right:0; bottom:0;
        background:#fff; z-index:100;
      }
    </style>
    <link href="fullcalendar/main.css" rel="stylesheet" />
    <link rel="stylesheet" href="../../css/spectre.min.css">
  </head>
  <body>
    <div>
      <p>Create your events on the week shown. (They repeat weekly.)</p>
      <p>When done, click <button id="upload" class="btn btn-primary">Upload</button>.</p>
      <p>All-day events are not supported.</p>
    </div>

    <script src="fullcalendar/main.js"></script>
    <script src="../../core/lib/customize.js"></script>

    <script>
      let calendar;

      document.addEventListener("DOMContentLoaded", function () {
        const calendarEl = document.getElementById("calendar");
        calendar = new FullCalendar.Calendar(calendarEl, {
          initialView: "timeGridWeek",
          headerToolbar: { left: "", center: "title", right: "timeGridWeek,listWeek" },
          navLinks: true,
          editable: true,
          selectable: true,
          selectMirror: true,
          nowIndicator: true,
          height: 600,
          initialDate: "2018-06-03",
          select: function (arg) {
            if (arg.allDay) {
              alert("All-day events are not supported. Please select a time range.");
              calendar.unselect();
              return;
            }
            const title = prompt("Event Title:");
            if (title) {
              calendar.addEvent({
                title: title.trim(),
                start: arg.start,
                end: arg.end,
                allDay: false
              });
            }
            calendar.unselect();
          },
          eventClick: function (arg) {
            if (confirm("Delete this event?")) arg.event.remove();
          }
        });
        calendar.render();
      });

      function buildSchedule() {
        const events = calendar.getEvents();
        const schedule = [];

        for (let i = 0; i < events.length; i++) {
          const e = events[i];
          if (!e.start || !e.end || e.allDay) continue; // skip invalid/all-day

          const s = new Date(e.start);
          const t = new Date(e.end);

          schedule.push({
            cn: String(e.title || "").trim(),
            dow: s.getDay(),            // 0=Sun..6=Sat
            sh: s.getHours(),
            sm: s.getMinutes(),
            eh: t.getHours(),
            em: t.getMinutes()
          });
        }

        // sort by start minute-of-week
        schedule.sort((a, b) => {
          const am = a.dow*1440 + a.sh*60 + a.sm;
          const bm = b.dow*1440 + b.sh*60 + b.sm;
          return am - bm;
        });

        return schedule;
      }

      document.getElementById("upload").addEventListener("click", function () {
        const schedule = buildSchedule();

        const app = `
/* Bangle.js 2 weekly schedule viewer (autogenerated) */
const Storage = require("Storage");
const Layout = require("Layout");
require("Font8x12").add(Graphics);
require("Font7x11Numeric7Seg").add(Graphics);

// ------- Data from uploader -------
const RAW_SCHEDULE = ${JSON.stringify(schedule)};

// Precompute minutes-of-week and sort (safety if user edits on-watch later)
const SCHEDULE = RAW_SCHEDULE.map(e => ({
  cn: e.cn,
  dow: e.dow|0,
  sh: e.sh|0,
  sm: e.sm|0,
  eh: e.eh|0,
  em: e.em|0,
  startMin: (e.dow|0)*1440 + (e.sh|0)*60 + (e.sm|0),
  endMin:   (e.dow|0)*1440 + (e.eh|0)*60 + (e.em|0)
})).sort((a,b)=>a.startMin-b.startMin);

// Persist JSON for other apps/tools if needed
Storage.writeJSON("schoolCalendar.json", SCHEDULE);

// ------- Helpers -------
function pad2(n){ return (n<10?"0":"")+n; }
function dayName(d, mode){ // 0=Sun..6=Sat
  const full = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
  const shrt = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  const one  = ["S","M","T","W","R","F","S"];
  if (mode===1) return full[d]||"";
  if (mode===2) return shrt[d]||"";
  return one[d]||"";
}
function nowMinuteOfWeek(){
  const n = new Date();
  return n.getDay()*1440 + n.getHours()*60 + n.getMinutes();
}
function findNextIndex(){
  if (!SCHEDULE.length) return -1;
  const m = nowMinuteOfWeek();
  for (let i=0;i<SCHEDULE.length;i++){
    if (SCHEDULE[i].startMin > m) return i;
  }
  return 0; // wrap-around to first of the week
}

// ------- UI State -------
let scene = "LIST"; // or "INFO"
let cursor = Math.max(0, findNextIndex()); // which row is 'selected'
let topIndex = 0; // topmost row in list viewport

// ------- Drawing -------
function drawList(){
  const R = Bangle.appRect;
  const W = R.w, H = R.h;
  g.reset();
  g.clearRect(R.x, R.y, R.x2, R.y2);

  // Time header
  const n = new Date();
  g.setFont("7x11Numeric7Seg",2);
  g.setFontAlign(1,-1);
  g.drawString(pad2(n.getHours())+":"+pad2(n.getMinutes()), R.x2-2, R.y+2);

  // Title
  g.setFont("8x12");
  g.setFontAlign(-1,-1);
  g.drawString("Weekly Schedule", R.x+2, R.y+2);

  // Table geometry
  const headerH = 24;
  const rowH = 18;
  const listTop = R.y + headerH + 4;
  const rowsFit = Math.max(3, Math.floor((R.y2 - listTop - 2) / rowH));

  // ensure topIndex keeps cursor visible
  if (cursor < topIndex) topIndex = cursor;
  if (cursor >= topIndex + rowsFit) topIndex = cursor - rowsFit + 1;

  // highlight "next" upcoming
  const nextIdx = findNextIndex();

  // draw rows
  for (let r=0; r<rowsFit; r++){
    const idx = topIndex + r;
    if (idx >= SCHEDULE.length) break;
    const y = listTop + r*rowH;

    // row border
    g.setColor(0.4,0.4,0.4);
    g.drawRect(R.x+1, y, R.x2-1, y+rowH);

    // highlight upcoming in yellow
    if (idx === nextIdx){
      g.setColor(1,0.8,0);
      g.drawRect(R.x+1, y, R.x2-1, y+rowH);
    }
    // highlight cursor in red
    if (idx === cursor){
      g.setColor(1,0,0);
      g.drawRect(R.x+2, y+1, R.x2-2, y+rowH-1);
    }

    const ev = SCHEDULE[idx];
    const label = pad2(ev.sh)+":"+pad2(ev.sm)+"-"+pad2(ev.eh)+":"+pad2(ev.em)
                  +" "+dayName(ev.dow,3)+" "+(ev.cn.length>20?ev.cn.slice(0,20)+"…":ev.cn);
    g.setColor(1,1,1);
    g.setFont("8x12");
    g.setFontAlign(-1,-1);
    g.drawString(label, R.x+6, y+2);
  }

  // footer hint
  g.setFont("6x8");
  g.setFontAlign(0,1);
  g.drawString("Swipe ↑/↓ to move • Tap to view", R.x + W/2, R.y2-2);
}

function drawInfo(){
  const R = Bangle.appRect;
  g.reset();
  g.clearRect(R.x, R.y, R.x2, R.y2);

  if (!SCHEDULE.length){
    g.setFont("8x12");
    g.setFontAlign(0,0);
    g.drawString("No events", R.x + R.w/2, R.y + R.h/2);
    return;
  }

  const ev = SCHEDULE[Math.min(cursor, SCHEDULE.length-1)];
  const titleLines = splitWords(ev.cn, 14);

  // Time header
  const n = new Date();
  g.setFont("7x11Numeric7Seg",2);
  g.setFontAlign(1,-1);
  g.drawString(pad2(n.getHours())+":"+pad2(n.getMinutes()), R.x2-2, R.y+2);

  // Details
  g.setFont("8x12",2);
  g.setFontAlign(-1,-1);
  let y = R.y + 30;
  for (let i=0;i<titleLines.length;i++){
    g.drawString(titleLines[i], R.x+6, y);
    y += 24;
  }

  g.setFont("8x12");
  g.drawString(dayName(ev.dow,1), R.x+6, y+6);
  g.drawString(pad2(ev.sh)+":"+pad2(ev.sm)+"-"+pad2(ev.eh)+":"+pad2(ev.em), R.x+6, y+24);

  // footer hint
  g.setFont("6x8");
  g.setFontAlign(0,1);
  g.drawString("Tap to return • Swipe ↑/↓ to pick", R.x + R.w/2, R.y2-2);
}

function splitWords(str, max){
  const out = [];
  let s = String(str||"");
  while (s.length > max){
    let cut = s.slice(0, max).lastIndexOf(" ");
    if (cut <= 0) cut = max;
    out.push(s.slice(0,cut));
    s = s.slice(cut).trimStart();
  }
  if (s) out.push(s);
  return out;
}

function draw(){
  if (scene === "LIST") drawList();
  else drawInfo();
}

// ------- Input (Bangle.js 2) -------
Bangle.on("swipe", (lr, ud) => {
  if (!SCHEDULE.length) return;
  if (ud === -1) { // swipe up -> previous
    if (cursor > 0) cursor--;
    draw();
  } else if (ud === 1) { // swipe down -> next
    if (cursor < SCHEDULE.length-1) cursor++;
    draw();
  }
});

// Single physical button exists; tap anywhere toggles scene
Bangle.on("touch", () => {
  scene = (scene === "LIST") ? "INFO" : "LIST";
  draw();
});

// ------- Setup -------
Bangle.loadWidgets();
Bangle.drawWidgets();
const tick = setInterval(draw, 15000); // refresh time display periodically
g.setClipRect(Bangle.appRect.x, Bangle.appRect.y, Bangle.appRect.x2, Bangle.appRect.y2);
draw();

// On unload, cleanup
Bangle.on("kill", () => { clearInterval(tick); });

// (Optional) Export a minimal API for other apps
global.getSchoolSchedule = () => SCHEDULE;
`;

        // Send finished app
        sendCustomizedApp({
          storage: [
            { name: "schoolCalendar.app.js", url: "app.js", content: app },
          ]
        });
      });
    </script>

    <div id="calendar"></div>
  </body>
</html>
