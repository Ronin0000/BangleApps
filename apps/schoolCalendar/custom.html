<html>
  <head>
    <meta charset="utf-8" />
    <title>School Calendar → Bangle.js 2</title>
    <style>
      body { padding:0; margin:0; font-family: system-ui, sans-serif; }
      html, body, #calendar { height:100%; width:100%; }
      #controls {
        position: sticky; top:0; z-index: 10;
        background:#fff; padding:10px; border-bottom:1px solid #ddd;
        display:flex; flex-wrap:wrap; gap:8px; align-items:center;
      }
      .spacer { flex: 1 1 auto; }
      details.google-setup {
        margin: 6px 10px; padding: 8px; border: 1px solid #ddd; border-radius: 6px; background:#fafafa;
      }
      .gs-row { display:flex; gap:8px; margin:6px 0; align-items: center; }
      .gs-row input { width: 460px; max-width: 80vw; }
      .muted { opacity: .8; font-size: 12px; margin: 4px 10px 8px; }
      .tag { font-size: 11px; padding:2px 6px; border:1px solid #ccc; border-radius: 10px; }
    </style>
    <link href="fullcalendar/main.css" rel="stylesheet" />
    <link rel="stylesheet" href="../../css/spectre.min.css">

    <!-- PRELUDE: define onload handlers early so async script tags can call them safely -->
    <script>
      // These flags are reused later by the main script.
      let gapiReady = false, gisReady = false;

      // Called by Google API script onload
      function gapiLoaded(){
        if (window.gapi && gapi.load) {
          gapi.load("client", async () => {
            if (typeof initGapi === "function") {
              try { await initGapi(); } catch(e){ console.error(e); }
            }
            // If main script already defined refreshSetupIndicators, update UI
            if (typeof refreshSetupIndicators === "function") refreshSetupIndicators();
          });
        }
      }
      // Called by Google Identity script onload
      function gisLoaded(){
        gisReady = true;
        if (typeof refreshSetupIndicators === "function") refreshSetupIndicators();
      }
    </script>

    <!-- Google APIs (async) -->
    <script src="https://apis.google.com/js/api.js" async defer onload="gapiLoaded()"></script>
    <script src="https://accounts.google.com/gsi/client" async defer onload="gisLoaded()"></script>
  </head>
  <body>
    <div id="controls">
      <button id="prev" class="btn">◀ Prev</button>
      <button id="today" class="btn">Today</button>
      <button id="next" class="btn">Next ▶</button>

      <div class="spacer"></div>

      <button id="signin" class="btn btn-primary" disabled>Sign in with Google</button>
      <button id="signout" class="btn" disabled>Sign out</button>

      <select id="calendarSelect" class="form-select" disabled>
        <option value="">Select a calendar…</option>
      </select>

      <select id="importRange" class="form-select" disabled title="How far to import from the current view start">
        <option value="0w">This week only</option>
        <option value="4w">Next 4 weeks</option>
        <option value="3m">Next 3 months</option>
        <option value="6m">Next 6 months</option>
        <option value="1y">Next 1 year</option>
      </select>

      <label class="form-switch" style="margin:0 8px;">
        <input id="clearBeforeImport" type="checkbox" checked>
        <i class="form-icon"></i> Clear existing before import
      </label>
      <button id="importWeek" class="btn" disabled>Import</button>
      <button id="upload" class="btn btn-success">Upload to Watch</button>
    </div>

    <details class="google-setup">
      <summary><strong>Google Setup</strong> <span class="tag" id="setupStatus">not saved</span></summary>
      <div class="gs-row">
        <label style="min-width:140px;">API Key</label>
        <input id="apiKey" type="text" placeholder="AIza... (Calendar API key)">
      </div>
      <div class="gs-row">
        <label style="min-width:140px;">OAuth Client ID</label>
        <input id="clientId" type="text" placeholder="xxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com">
      </div>
      <div class="gs-row">
        <button id="saveKeys" class="btn btn-primary">Save</button>
        <span class="muted">Keys are stored locally in your browser (localStorage).</span>
      </div>
      <div class="gs-row">
        <span class="muted">Add your origin (e.g. <code>https://ronin0000.github.io</code>) to OAuth “Authorized JavaScript origins”. Put your Gmail under “Test users”.</span>
      </div>
    </details>

    <p class="muted">
      Create or import events starting from the current week. They repeat weekly on the watch. All-day events are supported.
    </p>

    <div id="calendar"></div>

    <script src="fullcalendar/main.js"></script>
    <script src="../../core/lib/customize.js"></script>

    <script>
      // ---------- persisted settings (no-code) ----------
      const K = { API_KEY: "gcal_api_key", CLIENT_ID: "gcal_client_id" };
      const discoveryDoc = "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest";
      const scopes = "https://www.googleapis.com/auth/calendar.readonly";

      function loadSetting(k, d=""){ try { return localStorage.getItem(k) || d; } catch(e){ return d; } }
      function saveSetting(k, v){ try { localStorage.setItem(k, v||""); } catch(e){} }

      // ---------- UI elements ----------
      const el = id => document.getElementById(id);
      const btnPrev = el("prev"), btnNext = el("next"), btnToday = el("today");
      const btnSignin = el("signin"), btnSignout = el("signout");
      const selCal = el("calendarSelect"), selRange = el("importRange");
      const btnImport = el("importWeek"), btnUpload = el("upload"), chkClear = el("clearBeforeImport");
      const inputKey = el("apiKey"), inputClient = el("clientId"), btnSave = el("saveKeys"), setupStatus = el("setupStatus");

      // ---------- FullCalendar ----------
      let calendar;
      document.addEventListener("DOMContentLoaded", () => {
        const calendarEl = document.getElementById("calendar");
        calendar = new FullCalendar.Calendar(calendarEl, {
          initialView: "timeGridWeek",
          headerToolbar: { left: "", center: "title", right: "timeGridWeek,listWeek" },
          navLinks: true,
          editable: true,
          selectable: true,
          selectMirror: true,
          nowIndicator: true,
          height: "auto",
          initialDate: new Date().toISOString().slice(0,10),
          select: function (arg) {
            const title = prompt("Event Title:");
            if (!title) { calendar.unselect(); return; }
            calendar.addEvent({
              title: title.trim(),
              start: arg.start,
              end: arg.end,
              allDay: !!arg.allDay
            });
            calendar.unselect();
          },
          eventClick: function (arg) {
            if (confirm("Delete this event?")) arg.event.remove();
          }
        });
        calendar.render();
        btnPrev.onclick = () => calendar.prev();
        btnNext.onclick = () => calendar.next();
        btnToday.onclick = () => calendar.today();
      });

      // ---------- Google API bootstrap (continuation of prelude) ----------
      // Flags defined in prelude (top of file):
      // let gapiReady = false, gisReady = false;
      let tokenClient = null, authed = false;

      function refreshSetupIndicators(){
        const hasKey = !!loadSetting(K.API_KEY);
        const hasClient = !!loadSetting(K.CLIENT_ID);

        setupStatus.textContent = (hasKey && hasClient) ? "saved" : "not saved";
        setupStatus.style.color = (hasKey && hasClient) ? "green" : "red";

        // Only require keys to enable the button; libs can init on demand
        btnSignin.disabled = !(hasKey && hasClient);
        btnSignout.disabled = !authed;

        selCal.disabled   = !authed;
        selRange.disabled = !authed;
        btnImport.disabled = !authed || !selCal.value;
      }

      btnSave.addEventListener("click", async () => {
        saveSetting(K.API_KEY, inputKey.value.trim());
        saveSetting(K.CLIENT_ID, inputClient.value.trim());
        refreshSetupIndicators();
        // If gapi already present, re-init with the new key
        if (window.gapi && gapi.client) {
          try {
            await gapi.client.init({ apiKey: loadSetting(K.API_KEY), discoveryDocs: [discoveryDoc] });
            gapiReady = true;
          } catch (e) {
            console.error("gapi re-init error", e);
            alert("Failed to init Google API client. Check your API key.");
          }
        }
      });

      // preload inputs from storage
      window.addEventListener("load", () => {
        inputKey.value = loadSetting(K.API_KEY, "");
        inputClient.value = loadSetting(K.CLIENT_ID, "");
        refreshSetupIndicators();
      });

      async function initGapi(){
        try {
          await gapi.client.init({ apiKey: loadSetting(K.API_KEY), discoveryDocs: [discoveryDoc] });
          gapiReady = true;
          refreshSetupIndicators();
        } catch (e) {
          console.error("gapi init error", e);
          alert("Failed to init Google API client. Check your API key.");
        }
      }

      async function ensureGoogleReady(){
        // Wait/ensure gapi
        if (!gapiReady) {
          if (window.gapi && gapi.load) {
            await new Promise((res,rej)=>{
              gapi.load("client", async () => {
                try { await gapi.client.init({ apiKey: loadSetting(K.API_KEY), discoveryDocs: [discoveryDoc] }); gapiReady = true; res(); }
                catch(e){ rej(e); }
              });
            });
          } else {
            throw new Error("Google API script not loaded yet");
          }
        }
        // Ensure GIS token client (or refresh after keys change)
        if (!gisReady) throw new Error("Google Identity script not loaded yet");
        if (!tokenClient) {
          tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: loadSetting(K.CLIENT_ID),
            scope: scopes,
            callback: (resp) => {
              if (resp.error) {
                const msg = (resp.error === "access_denied")
                  ? "Access denied. Add your account under OAuth consent screen → Test users."
                  : "OAuth error: " + resp.error;
                alert(msg);
                console.error("OAuth error", resp);
                return;
              }
              gapi.client.setToken({ access_token: resp.access_token });
              authed = true;
              onAuthChanged(true);
              loadCalendarList();
            }
          });
        } else {
          tokenClient.client_id = loadSetting(K.CLIENT_ID);
        }
      }

      btnSignin.addEventListener("click", async () => {
        try {
          await ensureGoogleReady();
          tokenClient.requestAccessToken({ prompt: "consent" });
        } catch (e) {
          console.error(e);
          alert("Google libraries not ready yet. Save keys and try again.");
        }
      });

      btnSignout.addEventListener("click", () => {
        const tok = gapi.client.getToken();
        if (tok && tok.access_token) {
          try { google.accounts.oauth2.revoke(tok.access_token, ()=>{}); } catch(e){}
        }
        gapi.client.setToken(null);
        authed = false;
        onAuthChanged(false);
      });

      function onAuthChanged(isAuthed){
        btnSignin.disabled = isAuthed;
        btnSignout.disabled = !isAuthed;
        selCal.disabled = !isAuthed;
        selRange.disabled = !isAuthed;
        btnImport.disabled = !isAuthed || !selCal.value;
      }

      async function loadCalendarList(){
        try {
          const res = await gapi.client.calendar.calendarList.list({minAccessRole:"reader", showHidden:false, maxResults:250});
          const items = res.result.items || [];
          selCal.innerHTML = '<option value="">Select a calendar…</option>';
          items.forEach(c => {
            const opt = document.createElement("option");
            opt.value = c.id;
            opt.textContent = c.summary + (c.primary ? " (Primary)" : "");
            selCal.appendChild(opt);
          });
          selCal.onchange = () => { btnImport.disabled = !selCal.value || !authed; };
          // Auto-select first real calendar to reduce clicks
          if (selCal.options.length > 1) { selCal.selectedIndex = 1; selCal.onchange(); }
        } catch (e) {
          console.error(e);
          alert("Failed to load calendar list.");
        }
      }

      // ---------- Import logic (supports all-day and ranges up to 1 year) ----------
      function addDuration(baseDate, code){
        const d = new Date(baseDate);
        const n = parseInt(code,10);
        if (code.endsWith("w")) d.setDate(d.getDate() + n*7);
        else if (code.endsWith("m")) d.setMonth(d.getMonth() + n);
        else if (code.endsWith("y")) d.setFullYear(d.getFullYear() + n);
        return d;
      }

      btnImport.addEventListener("click", async () => {
        if (!selCal.value) { alert("Pick a calendar first."); return; }
        const view = calendar.view;
        const start = new Date(view.activeStart); // use current view start
        const rangeCode = selRange.value || "0w";
        const end = rangeCode==="0w" ? new Date(view.activeEnd) : addDuration(start, rangeCode);

        if (chkClear.checked) calendar.getEvents().forEach(ev => ev.remove());

        // Page through results if needed
        let pageToken = null, added = 0, skipped = 0, split = 0;
        try {
          do {
            const res = await gapi.client.calendar.events.list({
              calendarId: selCal.value,
              timeMin: start.toISOString(),
              timeMax: end.toISOString(),
              singleEvents: true,   // expand recurrences
              orderBy: "startTime",
              showDeleted: false,
              maxResults: 2500,
              pageToken
            });
            const items = res.result.items || [];
            for (const it of items) {
              const title = (it.summary || "").trim();

              // All-day event?
              if (it.start && it.start.date && !it.start.dateTime) {
                const s = new Date(it.start.date + "T00:00:00");
                const e = new Date(it.end.date + "T00:00:00");
                calendar.addEvent({ title, start: s, end: e, allDay: true });
                added++;
                continue;
              }

              // Timed event
              if (!it.start || !it.start.dateTime || !it.end || !it.end.dateTime) { skipped++; continue; }
              const s = new Date(it.start.dateTime);
              const e = new Date(it.end.dateTime);

              if (s.toDateString() === e.toDateString()) {
                calendar.addEvent({ title, start: s, end: e, allDay: false });
                added++;
              } else {
                // Split cross-midnight into two timed chunks
                const endOfStart = new Date(s); endOfStart.setHours(23,59,0,0);
                calendar.addEvent({ title, start: s, end: endOfStart, allDay: false });
                if (!(e.getHours()===0 && e.getMinutes()===0)) {
                  const startOfEnd = new Date(e); startOfEnd.setHours(0,0,0,0);
                  calendar.addEvent({ title, start: startOfEnd, end: e, allDay: false });
                }
                split++; added += 2;
              }
            }
            pageToken = res.result.nextPageToken || null;
          } while (pageToken);

          alert(`Imported ${added} events.${skipped?` Skipped ${skipped}.`:""}${split?` (${split} split over midnight)`: ""}`);
        } catch (e) {
          console.error(e);
          alert("Failed to import events. Check console.");
        }
      });

      // ---------- Build schedule & Upload ----------
      btnUpload.addEventListener("click", () => {
        const schedule = buildScheduleFromCalendar();
        const app = makeBangle2App(schedule);
        sendCustomizedApp({ storage: [{ name: "schoolCalendar.app.js", url: "app.js", content: app }] });
      });

      function buildScheduleFromCalendar() {
        const events = calendar.getEvents();
        const out = [];

        function pushTimed(title, s, e){
          out.push({
            cn: String(title||"").trim(),
            dow: s.getDay(),
            sh: s.getHours(), sm: s.getMinutes(),
            eh: e.getHours(), em: e.getMinutes(),
            ad: 0
          });
        }
        function pushAllDay(title, date){
          out.push({
            cn: String(title||"").trim(),
            dow: date.getDay(),
            sh: 0, sm: 0, eh: 23, em: 59,
            ad: 1
          });
        }

        for (const e of events) {
          if (!e.start || !e.end) continue;

          if (e.allDay) {
            const s = new Date(e.start);
            const end = new Date(e.end);
            for (let d = new Date(s); d < end; d.setDate(d.getDate()+1)) {
              pushAllDay(e.title, new Date(d));
            }
            continue;
          }

          const s = new Date(e.start), t = new Date(e.end);
          if (s.toDateString() === t.toDateString()) {
            pushTimed(e.title, s, t);
          } else {
            const endOfStart = new Date(s); endOfStart.setHours(23,59,0,0);
            pushTimed(e.title, s, endOfStart);
            if (!(t.getHours()===0 && t.getMinutes()===0)) {
              const startOfEnd = new Date(t); startOfEnd.setHours(0,0,0,0);
              pushTimed(e.title, startOfEnd, t);
            }
          }
        }

        // Sort: all-day first within each day, then time
        out.sort((a,b)=>{
          const am = a.dow*1440 + (a.ad? -1 : (a.sh*60 + a.sm));
          const bm = b.dow*1440 + (b.ad? -1 : (b.sh*60 + b.sm));
          return am - bm;
        });
        return out;
      }

      // ---------- Bangle.js 2 viewer (supports all-day) ----------
      function makeBangle2App(schedule){
        return `
const Storage=require("Storage");
const Layout=require("Layout");
require("Font8x12").add(Graphics);
require("Font7x11Numeric7Seg").add(Graphics);

const RAW=${JSON.stringify(schedule)};
const SCHEDULE=RAW.map(e=>({
  cn:e.cn, dow:e.dow|0, sh:e.sh|0, sm:e.sm|0, eh:e.eh|0, em:e.em|0, ad:e.ad?1:0,
  startMin:(e.dow|0)*1440 + (e.ad? -1 : ((e.sh|0)*60 + (e.sm|0)))
})).sort((a,b)=>a.startMin-b.startMin);

Storage.writeJSON("schoolCalendar.json", SCHEDULE);

function pad2(n){return(n<10?"0":"")+n;}
function dayName(d,m){const f=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
 const s=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]; const o=["S","M","T","W","R","F","S"];
 if(m===1)return f[d]||""; if(m===2)return s[d]||""; return o[d]||"";}
function nowMinuteOfWeek(){const n=new Date();return n.getDay()*1440+n.getHours()*60+n.getMinutes();}
function findNextIndex(){if(!SCHEDULE.length)return-1;const m=nowMinuteOfWeek();
 for(let i=0;i<SCHEDULE.length;i++){const ev=SCHEDULE[i];if(ev.ad? (ev.dow*1440 > m) : ((ev.dow*1440 + ev.sh*60+ev.sm) > m)) return i;} return 0;}

let scene="LIST",cursor=Math.max(0,findNextIndex()),topIndex=0;

function drawList(){
  const R=Bangle.appRect; g.reset(); g.clearRect(R.x,R.y,R.x2,R.y2);
  const n=new Date(); g.setFont("7x11Numeric7Seg",2).setFontAlign(1,-1);
  g.drawString(pad2(n.getHours())+":"+pad2(n.getMinutes()), R.x2-2, R.y+2);
  g.setFont("8x12").setFontAlign(-1,-1); g.drawString("Weekly Schedule", R.x+2, R.y+2);
  const headerH=24,rowH=18,listTop=R.y+headerH+4;
  const rows=Math.max(3,Math.floor((R.y2-listTop-2)/rowH));
  if(cursor<topIndex)topIndex=cursor; if(cursor>=topIndex+rows)topIndex=cursor-rows+1;
  const next=findNextIndex();
  for(let r=0;r<rows;r++){
    const idx=topIndex+r; if(idx>=SCHEDULE.length)break; const y=listTop+r*rowH; const ev=SCHEDULE[idx];
    g.setColor(.4,.4,.4).drawRect(R.x+1,y,R.x2-1,y+rowH);
    if(idx===next){g.setColor(1,.8,0).drawRect(R.x+1,y,R.x2-1,y+rowH);}
    if(idx===cursor){g.setColor(1,0,0).drawRect(R.x+2,y+1,R.x2-2,y+rowH-1);}
    const time = ev.ad ? "All-day" : (pad2(ev.sh)+":"+pad2(ev.sm)+"-"+pad2(ev.eh)+":"+pad2(ev.em));
    const label = time+" "+dayName(ev.dow,3)+" "+(ev.cn.length>20?ev.cn.slice(0,20)+"…":ev.cn);
    g.setColor(1,1,1).setFont("8x12").setFontAlign(-1,-1); g.drawString(label, R.x+6, y+2);
  }
  g.setFont("6x8").setFontAlign(0,1);
  g.drawString("Swipe ↑/↓ • Tap", R.x+R.w/2, R.y2-2);
}
function splitWords(s,m){const out=[];s=String(s||"");while(s.length>m){let c=s.slice(0,m).lastIndexOf(" ");if(c<=0)c=m;out.push(s.slice(0,c));s=s.slice(c).trimStart();}if(s)out.push(s);return out;}
function drawInfo(){
  const R=Bangle.appRect; g.reset(); g.clearRect(R.x,R.y,R.x2,R.y2);
  if(!SCHEDULE.length){g.setFont("8x12").setFontAlign(0,0);g.drawString("No events",R.x+R.w/2,R.y+R.h/2);return;}
  const ev=SCHEDULE[Math.min(cursor,SCHEDULE.length-1)], lines=splitWords(ev.cn,14);
  const n=new Date(); g.setFont("7x11Numeric7Seg",2).setFontAlign(1,-1);
  g.drawString(pad2(n.getHours())+":"+pad2(n.getMinutes()), R.x2-2, R.y+2);
  g.setFont("8x12",2).setFontAlign(-1,-1); let y=R.y+30; lines.forEach(L=>{g.drawString(L,R.x+6,y);y+=24;});
  g.setFont("8x12"); g.drawString(dayName(ev.dow,1), R.x+6, y+6);
  g.drawString(ev.ad?"All-day":(pad2(ev.sh)+":"+pad2(ev.sm)+"-"+pad2(ev.eh)+":"+pad2(ev.em)), R.x+6, y+24);
  g.setFont("6x8").setFontAlign(0,1); g.drawString("Tap to return • Swipe ↑/↓", R.x+R.w/2, R.y2-2);
}
function draw(){ if(scene==="LIST") drawList(); else drawInfo(); }

Bangle.on("swipe",(lr,ud)=>{ if(!SCHEDULE.length)return; if(ud===-1){if(cursor>0)cursor--;draw();} else if(ud===1){if(cursor<SCHEDULE.length-1)cursor++;draw();}});
Bangle.on("touch",()=>{scene=(scene==="LIST")?"INFO":"LIST";draw();});
Bangle.loadWidgets(); Bangle.drawWidgets();
const tick=setInterval(draw,15000); g.setClipRect(Bangle.appRect.x,Bangle.appRect.y,Bangle.appRect.x2,Bangle.appRect.y2);
draw(); Bangle.on("kill",()=>clearInterval(tick));
`;
      }

      // Uploader shim for Espruino App Loader
      function sendCustomizedApp(payload){ window.postMessage({type:"customize-app", payload}, "*"); }
    </script>
  </body>
</html>
